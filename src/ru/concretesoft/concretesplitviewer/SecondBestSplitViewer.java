/*
 * SecondBestSplitViewer.java
 *
 * Created on 30 Июнь 2006 г., 0:17
 */

package ru.concretesoft.concretesplitviewer;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.HashSet;
import java.util.Iterator;
import java.util.TreeSet;
import java.util.Vector;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import ru.spb.ConcreteSoft.tipWindow.MouseMoveQueue;
import ru.spb.ConcreteSoft.tipWindow.TipWindow;

/**
 *
 * @author Мытинский Леонид
 *
 * Панель для отображения сплитов в виде относительно второго лучшего
 */
public class SecondBestSplitViewer extends javax.swing.JPanel implements SplitViewer,ListDataListener,ListSelectionListener, MouseListener{
    private AthleteListModel aModel;
    private HashSet<Group> groups;
    private Time[] secondBest;
    private Time[] best;
    private boolean draw = false;
    private int[] xCoord;
    
    private int otst;
    private Vector<int[]> yCoord;
    private int[] prom;
    private int yMax;

//    private TipWindow tipWindow;

    private int yMin;
    /** Creates new form SecondBestSplitViewer */
    public SecondBestSplitViewer() {
        initComponents();

        groups = new HashSet<Group>();
        otst = -1;
        addMouseMotionListener(MouseMoveQueue.getInstance());
        addMouseListener(this);
//        tipWindow = new TipWindow();
////        tipWindow.setVisible(true);
//        TipThreadSplitViewer tipThread = new TipThreadSplitViewer(tipWindow, this);
//        tipThread.start();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {

        setLayout(new java.awt.GridBagLayout());

    }// </editor-fold>//GEN-END:initComponents
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    public void paint(Graphics g){
        Graphics2D g2 = (Graphics2D)g;
        Dimension d = getSize();
        g2.setPaint(Color.WHITE);
        g2.fillRect(0,0,d.width,d.height);
        g2.setPaint(Color.BLACK);
        FontMetrics fM = g2.getFontMetrics();
        otst = (otst==-1)? fM.stringWidth("-000:00")+5: otst;
        int width = d.width-otst;
        int height = d.height-fM.getHeight()-2;
        Distance dist = aModel.getDistance();
        AthleteIcon[] athletes = (AthleteIcon[])(aModel.getSelectedValues());
        int[] splits = aModel.getViewingSplits();
        
        if(draw){
            int[] sizes = new int[splits.length];
            int tL = 0;
            int totalLength = 0;
            prom = new int[sizes.length]; 
            for(int i=0;i<sizes.length;i++){
                tL+=secondBest[splits[i]-1].getTimeInSeconds();
                prom[i]=tL;
                totalLength+=dist.getLengthOfDist(splits[i]);
            }
            int x=otst;
            xCoord = new int[sizes.length];
            for(int i=0;i<sizes.length;i++){
                sizes[i] = (int)(((double)dist.getLengthOfDist(splits[i])/totalLength)*width);
                g2.drawLine(x+sizes[i],0,x+sizes[i],height);
                String s;
                if(i<=(splits.length-2)){
                    int diff = splits[i+1]-splits[i];
                    if(diff>1) 
                        s = splits[i]+"-"+(splits[i+1]-1);
                    else 
                        s=splits[i]+"";
                } else {
                    if(splits[i]==dist.getNumberOfCP()) 
                        s=java.util.ResourceBundle.getBundle("ru/concretesoft/concretesplitviewer/i18on").getString("Finish");
                    else 
                        s = splits[i]+"";
                }
                g2.drawString(s,x+sizes[i]-fM.stringWidth(s)/2,height+fM.getHeight()+1);
                x+=sizes[i];
                xCoord[i] = x;
            }
            calculateYCoord();
            int h = yMax-yMin;
           
            int hTime = fM.getHeight();
            double stepTime = 30.0;
            int nT =(int) (h / stepTime);
            while(nT == 0){
                stepTime = Math.round(stepTime/2);
                nT = (int)(h / stepTime);
            }
            while((height/nT)<(hTime+10)){
                stepTime*=2;
                nT = (int) (h / stepTime);
            }
            Time tmp = new Time(0,2);
            tmp.setTimeInSeconds(Math.abs(yMin));
            String s = tmp.getTimeString();
            int y0 = (int)(((-yMin)/(double)h)*height);
            
            if(yMin<0)
                s = "-"+tmp.getTimeString();
            else if(yMin>0)
                s = "+"+tmp.getTimeString();
            else 
                s = tmp.getTimeString();
            
            g2.setPaint(Color.BLACK);
            g2.drawString(s,otst-fM.stringWidth(s),hTime-1);
             float dash1[] = {10.0f};
            BasicStroke dashed = new BasicStroke(1.0f, 
                                                  java.awt.BasicStroke.CAP_BUTT, 
                                                  java.awt.BasicStroke.JOIN_MITER, 
                                                  10.0f, dash1, 0.0f);
            g2.setStroke(dashed);
            for(int i=1;i<=nT;i++){
                int timeCur = yMin + (Math.abs(yMin) % (int)stepTime) + (int)(stepTime*i);
                
                tmp.setTimeInSeconds(Math.abs(timeCur));
                
                if(timeCur<0){
                    s = "-"+tmp.getTimeString();
                     
                } else if(timeCur>0){
                    s = "+"+tmp.getTimeString();
                } else 
                    s = tmp.getTimeString();
                
                int yH = (int)((timeCur-yMin)/(double)h*height);
//                yH = (int)((stepTime*i / h)*height);
                g2.setPaint(Color.BLACK);
                g2.drawString(s,otst-fM.stringWidth(s),yH);
               
                g2.setPaint(Color.LIGHT_GRAY);
                g2.drawLine(otst,yH,otst + width,yH);
            }
            g2.setStroke(new BasicStroke(1.0f));
           
            g2.setPaint(Color.LIGHT_GRAY);
            g2.drawLine(otst,y0,xCoord[xCoord.length-1],y0);
            Iterator<int[]> it = yCoord.iterator();
            int k=0;
            while(it.hasNext()){
                
                g2.setPaint(athletes[k].getColor());
                int[] yC = it.next();
                int y = (int)(((yC[0]-yMin)/(double)h)*height);

                g2.drawLine(otst,y0,xCoord[0],y);
                for(int i=1;i<splits.length;i++){

                    int y2 = (int)(((yC[i]-yMin)/(double)h)*height);
                    g2.drawLine(xCoord[i-1],y,xCoord[i],y2);
                    //                   System.out.println(xCoord[i-1]+"  "+y+"  "+xCoord[i]+"  "+y2);
                    y=y2;

                }
                k++;
            }
//            for(int j=0;j<yCoord.size();j++){
//                g2.setPaint(colorSheme[j]);
//                int y = (int)(((yCoord[j][0]-yMin)/(double)h)*height);
//                
//                g2.drawLine(otst,y0,xCoord[0],y);
//                for(int i=1;i<splits.length;i++){
//                   
//                   int y2 = (int)(((yCoord[j][i]-yMin)/(double)h)*height);
//                   g2.drawLine(xCoord[i-1],y,xCoord[i],y2);
////                   System.out.println(xCoord[i-1]+"  "+y+"  "+xCoord[i]+"  "+y2);
//                   y=y2;
//                   
//                }
//            }
            
        }else{
            xCoord=null;
        }
    }
    
//    public boolean setColorSheme(Color[] c) {
//        boolean value = false; 
//        if((c==null)||(c.length!=aModel.getAthletes().size())){
//            int size = aModel.getAthletes().size();
//            colorSheme = new Color[size];
//            for(int i=0;i<size;i++){
//                colorSheme[i]=convertToColor( i*( 1024 / size ));
//            }
//            value = false;
//        }else{
//            colorSheme = c;
//            value = true;
//        }
//        setDraw();
//        return value;
//        
//    }

    private Color convertToColor(int c){
        if(c<=255)
            return new Color(255,c,0);
        if(c<=511)
            return new Color(511-c,255,0);
        if(c<=767)
            return new Color(0,255,c-511);
        if(c<=1023)
            return new Color(0,1021-c,255);
        return null;
    }
    private Time max(Time t1,Time t2){
        if(t1.getTimeInSeconds()>t2.getTimeInSeconds())
            return t1;
        else 
            return t2;
    }
    private Time min(Time t1,Time t2){
        if(t1.getTimeInSeconds()<t2.getTimeInSeconds())
            return t1;
        else 
            return t2;
    }
    public String toString(){
        return java.util.ResourceBundle.getBundle("ru/concretesoft/concretesplitviewer/i18on").getString("Second_Best_View");
    }
    private void setDraw(){
        draw = (secondBest != null) && (aModel.getViewingSplits() != null) && (aModel.getSelectedValues().length != 0);
    }


    public void removeSplit(int x) {
        if(xCoord!=null){
            for(int i=0;i<xCoord.length;i++){
                if(x<xCoord[i]){
                    aModel.removeSplitsForN(aModel.getViewingSplits()[i]);
                    break;
                }
            }
        }
    }

  
    private void calculateYCoord(){
        
        AthleteIcon[] athletes = (AthleteIcon[])(aModel.getSelectedValues());
        yMax = 0;
        yCoord = new Vector<int[]>();
        
        yMin = 0;

        for(int i=0;i<athletes.length;i++){
            Athlete a = athletes[i].getAthlete();
            treatmentOneAthlete(a);
            
        }
        
        
    }
    private void treatmentOneAthlete(Athlete a){
        yMax--;
        yMin++;
        int[] splits = aModel.getViewingSplits();
        if (yCoord==null) yCoord = new Vector<int[]>();
        else;
        yCoord.add(new int[splits.length]);
        yCoord.lastElement()[0] = a.getLap(splits[0]).getTimeInSeconds()-prom[0];

        if(yCoord.lastElement()[0]<yMin)yMin=yCoord.lastElement()[0];
        else if(yCoord.lastElement()[0]>yMax)yMax=yCoord.lastElement()[0];
        else;

        int tot = 0;
        for(int i = 0;i<splits.length;i++){
            tot += a.getLap(splits[i]).getTimeInSeconds();
            yCoord.lastElement()[i] = tot - prom[i];
            if(yCoord.lastElement()[i]<yMin)yMin=yCoord.lastElement()[i];
            if(yCoord.lastElement()[i]>yMax)yMax=yCoord.lastElement()[i];
        }
        yMax++;
        yMin--;
    }
    public void setModel(AthleteListModel aM){
        aModel = aM;
        aM.addListDataListener(this);
        aM.addListSelectionListener(this);
    }
    public AthleteListModel getModel(){
        return aModel;
    }



    public void intervalAdded(ListDataEvent e) {
        contentsChanged(e);
    }

    public void intervalRemoved(ListDataEvent e) {
        contentsChanged(e);
    }

    public void contentsChanged(ListDataEvent e) {
//        calculateYCoord();
        if(aModel.getDistance()==null){
            secondBest = null;
        }else{
            Object[] allSelected = aModel.getGroupsList().getSelectedValues();
            Vector<Group> groups = new Vector<Group>();
            for(Object g : allSelected)
                groups.add((Group)g);
            
            secondBest = Tools.getAnyBest(groups,2);
        }
        setDraw();
        repaint();
    }

    public void valueChanged(ListSelectionEvent e) {
//        calculateYCoord();
        setDraw();
        repaint();
    }
    
    public int getSplit(Point p){
        if(xCoord!=null){
            for(int i=0;i<xCoord.length; i++){
                if(p.getX()<xCoord[i]){
                    return aModel.getViewingSplits()[i];
                }else;
            }
        }else{
            return -1;
        }
        return -1;
    }

    public void mouseClicked(MouseEvent evt) {
        if((evt.getButton()==evt.BUTTON2)||(evt.getMouseModifiersText(evt.getModifiers()).equals("Shift+Button1"))){
            aModel.restoreAllSplits();
        }
        else if(evt.getButton()==evt.BUTTON1){
            
            removeSplit(evt.getX());
        }
    }

    public void mousePressed(MouseEvent e) {
    }

    public void mouseReleased(MouseEvent e) {
    }

    public void mouseEntered(MouseEvent e) {
    }

    public void mouseExited(MouseEvent e) {
    }
}
